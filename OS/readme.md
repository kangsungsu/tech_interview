## 운영체제란
-  사용자로 하여금 컴퓨터의 하드웨어를 보다 쉽게 사용할 수 있도록 인터페이스를 제공해주는 소프트웨어

|특징|설명|
|---|-----|
|사용자 편리성 제공| 한정된 시스템 자원을 사용할 수 있도록 관리 및 운영|
|인터페이스|컴퓨터 시스템과 사용자를 연결|
|스케쥴링 담당|다중 사용자와 다중 응용 프로그램 환경하에서 자원의 현재 상태를 파악하고 자원 분배를 위한 스케줄링 담당|
|자원 관리|CPU, 메모리 공간, 기억장치, 입출력 장치 등의 자원을 관리함|
|제어 기능|입출력 장치와 사용자 프로그램을 제어|

- 운영체제의 종류: 윈도우, 리눅스, 맥, 안드로이드 등

## 스케줄러
- 한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록 다음 실행 시간에 실행할 수 있는 프로세스 중에 하나를 선택하는 역할

  ### 스케줄러 큐
  - Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합
  - Ready Queue : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
  - Device Queue : Device I/O 작업을 대기하고 있는 프로세스의 집합

  ### 종류
  - 장기 스케줄러 : 한정된 메모리에 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리에 임시로 저장된다.이 pool에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 ready queue로 보낼지 결정
    - 메모리와 디스크 사이의 스케줄링을 담당
    - 프로세스에 memory를 할당
    - 프로세스의 상태 : New -> Ready
  - 단기 스케줄러 : CPU와 메모리 사이의 스케줄링을 담당하는스케줄러
    - Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정.
    - 프로세스에 CPU를 할당
    - 프로세스의 상태 : ready -> running -> waiting -> ready
  - 중기 스케줄러 : 여유 공간 마련을 위해 프로세스를 통쨰로 메모리에서 디스크로 쫓아냄
    - 프로세스에게서 memory를 deallocate
    - 프로세스의 상태 : ready ->suspended

## CPU 스케줄러
- 레디 큐에 존재하는 프로세스들을 특정한 우선순위를 기반으로 CPU를 할당받게 해주는 역할로 단기 스케줄러와 같은 의미.
  ### 목표
  - CPU 활용 최대화
  - 평균 대기시간 최소화
  - 처리량 최대화

  ### 비선점 스케줄러
  - 정의 : CPU를 사용하는 프로세스가 자율적으로 반납하는 방식
  - FCFS : 먼저 들어온 게 먼저 처리되는 형식
  - SJF : 남은 프로세스 중 시간이 가장 짧은 것부터 처리되는 형식
  - HRN : 대기 중인 프로세스 중 대기시간이 긴 프로세스일 경우 우선순위가 높아지게 한다.기아 현상 해소
    - HRN 우선순위 계산식: ( 대기시간 + 서비스 시간)/서비스 시간
    
  ### 선점 스케줄러
  - 정의 : 높은 우선순위를 가지는 프로세스는 항상 먼저 스케줄되어야 한다.
  - 다단계 큐: 작업들을 여러 종류 그룹으로 분할, 여러 개의 큐를 이용하여 상위단계 작업이 선점.
  - SRT : 최단시간인 프로세스가 있다면 현재 진행중인 프로세스도 sleep시키고 할당하는 방식
  - Round Robin(RR) : 모든 프로세스가 같은 우선순위라고 생각하고 time slice를 기준으로 스케줄링한다.
  
  :smile: 사용 용어
  |용어|설명|
  |---|---|
  |서비스 시간|프로세스가 결과를 산출하기까지 소요되는 시간|
  |응답시간|프로세스들이 입력외어 수행하고 결과를 산출하기까지 소요ㅚ는 시간|
  |평균 응답 시간|대기 큐의 프로세스가 겨로가를 산출하기 소요되는 시간 평균|
  |대기시간| 프로세스가 프로세서에 할당되기까지 큐에 대기하는 시간|
  |종료 시간| 요구되는 프로세스를 모두 수행하고 종료된 시간|
  |시간 할당량|한 프로세스가 프로세서를 독점하는 것을 방지하기 위해 서비스되는 시간|
  |응답률|HRN에서 사용되는 계산|
  


## 프로세스 vs 스레드
- 프로세스: 운영체제로부터 자원을 할당받은 작업의 단위. CPU에 의해 처리되는 사용자 프로그램
- 스레드: 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위. 한개의 프로세스는 여러개의 스레드를 가짐

|프로세스 상태|설명|
|---|-----|
|생성|사용자에 의해 프로세스가 생성된 상태|
|준비| CPU를 할당받을 수 있는 상태|
|실행|프로세스가 CPU를 할당받아 동작중인 상태|
|대기|프로세스 실행 중 입출력 처리 등으로 인해 cpu를 양도하고 입출력 처리가 완료까지 대기리스트에서 기다리는 상태|
|완료|프로세스가 cpu를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태|


|구분|프로세스|스레드|
|---|---|---|
|요소 기술|PCB,텍스트,데이터,힙,스택|스레드ID, 레지스터 집합,스택|
|통신 방법|프로세스 간 통신은 IPC,Pipe,Message, 공유메모리 등을 사용| 스레드 간 통신에는 IPC,Pipe 뿐만 아니라 전역 변수도 사용가능|
|시스템 부하| 문맥전환을 통해 프로세스 간 전환이 일어나기 때문에 시스템 부하가 큼| 경량화된 문맥전환을 사용하여 시스템 부하가 적음|
|활용|운영체제의 기본 구성요소|Multi Thread를 사용한 서버|
|라이브러리 함수|fork()|pthread_create()|

## 프로세스 주소공간

![image](https://user-images.githubusercontent.com/51367515/148778710-de324904-ca8f-47f4-9c4a-52d01951f2d4.png)

|프로세스 구성요소|설명|
|---|-----|
|코드|사용자가 작성한 코드|
|데이터|코드에서 사용하는 데이터|
|스택|함수 호출 및 인자 값 전송에 사용|
|PCB|운형체제가 프로세스 관리를 위해 필요한 자료를 담고있는 자료구조|

- code
  - 함수, 제어문, 상수 등
  - Read-Only

- Data
  - 전역병수와 정적 변수가 저장되는 영역
  - Read-Write
 
- Stack
  - 지역 변수와 매개변수가 저장되는 영역
  - 함수의 호출이 완료되면 소멸
  - 컴파일 타임에 크기가 결정
  
- Heap
  - 런타임에 크기가 결정되는 메모리 영역
  - 사용자에 의해 메모리 공간이 동적으로 할당, 해제

:smile: 프로세스의 구역을 나눈 이유?
- 데이터를 공유하여 메모리 사용량을 줄이기 위하여

## 인터럽트

- 정의 : CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것

- 종류
  - 하드웨어 인터럽트 : 하드웨어가 발생시키는 인터럽트로, CPU가 아닌 다른 하드웨어 장치가 cpu에 어떤 사실을 알려주거나 cpu 서비스를 요청해야 할 경우 발생
    1. 기계검사 인터럽트 - 프로그램을 실행하는 도중 갑작스런 정전이나 컴퓨터 자체 내에서 기계적인 문제가 발생한 경우
    2. 외부 인터럽트 - 오퍼레이터나 타이머에 의해 의도적으로 프로그램이 중단된 경우
    3. 입출력 인터럽트 - 입출력의 종료나 입출력의 오류에 의해 CPU의 기능이 요청되는 경우
    4. 프로그램검사 인터럽트 - 프로그램 실행 중 보호된 기억공간 내에 접근하거나 불법적인 명령 수행과 같은 프로그램의 문제가 발생한 경우
  - 소프트웨어 인터럽트 : 소프트웨어 인터럽트는 외부가 아닌 CPU 내부에서 자신이 실행한 명령이나 CPU의 명령 실행에 관련된 모듈이 변화하는 경우 발생
    😸 예외: 프로그램 실행 중 프로그램 상의 처리 불가능한 오류나 이벤트를 알리기 위한 장치
    1. 존재하지 않는 메모리에 접근할 때
    2. 0으로 나눈 경우
    3. SVC

## 시스템 콜
- 정의 : 운영 체제의 커널이 제공하는 서비스에 접근하기 위한 인터페이스를 요청하는 함수. User Mode에서 사용하기 힘든 작업을 위해 kernel mode로 변경해준다.

- Kernel Mode
  - 시스템의 모든 메모리에 모든 CPU 명령을 실행 할 수 있다.
- User mode
   - 사용자 애플리케이션 코드가 실행한다.
   - 시스템 데이터에 제한된 접근

:smile: kernel Mode가 존재하는 이유: 프로세스의 실행, 종료나 I/O 작업 등의 사용자가 함부로 사용하면 문제가 될 수 있는 명령들이 있으므로

## PCB
- 정의 : 프로세스 메타데이터들을 저장하는 곳. 교체 작업이 이루어질 때, 앞으로 다시 수행할 Block 상태의 프로세스의 상태값을 PCB에 저장해두는 것입니다.
- 저장 순서 : 프로그램 실행 -> 프로세스 생성 -> 프로세스 주소 공간에 (코드, 데이터, 스택) 생성 -> 이 프로세스의 메타데이터들이 PCB에 저장
- 프로세스 구조
  - Process State : 프로세스 상태(Create, Ready, Running, Block, terminated)
  - Process Counter : 다음 실행할 명령어의 주솟값

## Context Switching
- 정의 : CPU가 현재 실행하고 있는 Task(Process, Thread)의 상태를 저장하고, 다음 진행할 Task의 상태 및 Register 값들에 대한 정보(Context)를 읽어 새로운 Task의 Context 정보로 교체하는 과정
- 수행과정
  1. Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리가 되고 있습니다.

  2. 현재 실행하고 있는 Task의 PCB 정보를 저장하게 됩니다.(Process Stack, Ready Queue)

  3. 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있게 됩니다.


## IPC
- 정의 : 프로세스간의 통신
- 종류
  1. pipe
    - 두개의 프로세스를 연결하고, 하나는 데이터를 쓰기만 하나는 읽기만 하는 통신
    - 장점 : 매우 간단함
    - 단점 : 읽기와 쓰기 통신 모두를 해야 한다면 PIPE를 두개 만들어야 하는데, 구현이 꽤나 복잡해 질 수 있습니다.
  2. Message Queue
    - 선입선출의 자료구조를 가지는 통신 커널
    - 메모리 공간
  3. Shared Memory
    - 공유메모리가 데이터 자체를 공유하도록 지원하는 설비
  4. Memory Map
    - 열린 파일을 메모리에 맴핑시켜서 공유
  5. socket 통신
 
 
## 페이지 교체 알고리즘

- OPT - Optimal : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
- FIFO - First In First Out
- LRU - Least Recently Used : 가장 오랫동안 사용되지 않은 페이지 교체
- LFU - Least Frequently Used : 참조 횟수가 가장 작은 페이지 교체
- MFU - Most Frequently used : 참조 횟수가 가장 많은 페이지 교체
- NUR - Not Used Recently : 최근에 사용하지 않은 페이지 교체

## 데드락
- 정의 : 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생

- 발생 조건

  - 교착 상태는 한 시스템 내에서 다음의 네 가지 조건이 동시에 성립 할 때 발생

  1) 상호 배제 (Mutual exclusion)

  - 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.

  2) 점유 대기 (Hold and wait)

  - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.

   3) 비선점 (No preemption)

  - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.

  4) 순환 대기 (Circular wait)

  - 프로세스의 집합 {P0, P1, ,…Pn}에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2…Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.

 - 데드락(Deadlock)의 해결법
  - 데드락이 발생하지 않도록 예방(prevention) 하기
  - 데드락 발생 가능성을 인정하면서도 적절하게 회피(avoidance) 하기
  - 데드락 발생을 허용하지만 데드락을 탐지(detection)하여, 데드락에서 회복하기

## Race Condition
- 정의 : 두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 같지 않고 달라지는 상황

## Semaphore

![image](https://user-images.githubusercontent.com/51367515/149927574-4086678f-636f-4f3d-a8e4-7d09613fa79f.png)

- 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것
- 리소스의 상태를 나타내는 간단한 카운터라고 할 수 있는데, 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 이용하게 되며, 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 동기화 시키는 기술이다. 다시 말해서 하나의 스레드만 들어가게 할 수도 있고 여러 개의 스레드가 들어가게 할 수 있다.

 

## Mutex(뮤텍스)

![image](https://user-images.githubusercontent.com/51367515/149927743-8cfbb9cf-bc48-496b-a31b-a5a016623ea0.png)

- 공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 방법
- Critical Section(각 프로세스에서 공유 데이터를 엑세스하는 프로그램 코드 부분)을 가진 쓰레드들의 Running time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술
- 다중 프로세스들이 공유 리소스에 대한 접근을 조율하기 위해 locking과 unloking을 사용하는데, 다시 말해서 상호배제를 함으로써 두 쓰레드가 동시에 사용할 수 없다는 뜻이다.

## 페이징(Paging)
- 논리(가상) 메모리는 페이지(Page)이라 불리는 고정 크기의 블록으로 나누어지고, 물리 메모리는 프레임(Frame)라 불리는 페이지과 같은 크기의 블록들로 나누어짐. 보조 메모리 역시 프레임과 같은 크기의 블록들로 나누어짐.
- 사용자는 하나의 주소를 지정(하드웨어의 의해 페이지 번호와 변위로 분할)
- 페이지 테이블에는 각 페이지 번호와 그에 해당하는 프레임의 시작 물리 주소를 저장
- 할당은 항상 프레임의 정수 배로 할당되는데, 이 때 프로세스가 페이지 경계와 일치하지 않는 크기의 메모리를 요구하게 되면 마지막 페이지 프레임은 전부 사용되지 않고 남아버리는 문제가 발생한다.(내부 단편화)


## 세그먼테이션(Segmentation)
- 페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할
- 사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위)
- 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장
서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(외부 단편화)
